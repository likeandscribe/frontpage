diff --git a/build/index.d.ts b/build/index.d.ts
index c0fff1f253230b19abe8cc864873a573d2ee38a1..36c696c741b03eef7e62806251c074a77f9a8517 100644
--- a/build/index.d.ts
+++ b/build/index.d.ts
@@ -920,6 +920,10 @@ export interface DPoPOptions extends CryptoKeyPair {
      * will be used automatically.
      */
     nonce?: string;
+    /**
+     * The DPoP Proof JWT's expiration time in seconds. If not supplied the JWT will have no expiry.
+     */
+    expiresIn?: number;
 }
 export interface DPoPRequestOptions {
     /**
diff --git a/build/index.js b/build/index.js
index 4a178ba05262a04b75ad9f73035ed1b80c8aa872..c96efc48b7a97ead9db4c7d715b690e83eaea5f4 100644
--- a/build/index.js
+++ b/build/index.js
@@ -539,6 +539,7 @@ async function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken)
     if (!publicKey.extractable) {
         throw new TypeError('"DPoP.publicKey.extractable" must be true');
     }
+    const expiresIn = options.expiresIn;
     const now = epochTime() + clockSkew;
     const proof = await jwt({
         alg: keyToJws(privateKey),
@@ -546,6 +547,7 @@ async function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken)
         jwk: await publicJwk(publicKey),
     }, {
         iat: now,
+        exp: expiresIn !== undefined ? now + expiresIn : undefined,
         jti: randomBytes(),
         htm,
         nonce,
@@ -896,7 +898,7 @@ export async function processUserInfoResponse(as, client, expectedSubject, respo
 }
 async function authenticatedRequest(as, client, method, url, body, headers, options) {
     await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);
-    headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
+    headers.set('content-type', 'application/x-www-form-urlencoded');
     return (options?.[customFetch] || fetch)(url.href, {
         body,
         headers: Object.fromEntries(headers.entries()),
